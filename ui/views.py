from datetime import timedelta
from enum import Enum

from .models import Archive, VTResults, File, Metadata, PEHeaderInfo
from rest_framework import viewsets, permissions
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import MethodNotAllowed, ParseError
from .serializers import VTResultSerializer, FileSerializer, ArchiveSerializer
from .serializers import PEHeaderInfoSerializer, MetadataSerializer
from django.http import HttpResponse
from django.http import HttpRequest


class ArgMap(Enum):
    filename = "FileName"
    path = "Path"
    filetype = "FileType"
    sha256 = "SHA256"
    sha1 = "SHA1"
    md5 = "MD5"
    ssdeep = "SSDeep"
    imphash = "ImpHash"
    compiletime = "CompileTime"
    archive = "Archive"
    file_id = "FileID"


class MethodIndependentArgsMixin:

    @staticmethod
    def _get_arguments(request: HttpRequest):
        if request.method == "GET":
            source = request.GET
        elif request.method == "POST":
            source = request.POST
        else:
            raise MethodNotAllowed("WTF are you doing?")
        args = {name: source.get(name.value, None) for name in ArgMap}
        return args


class FileViewSet(viewsets.ModelViewSet, MethodIndependentArgsMixin):
    queryset = File.objects.all()
    serializer_class = FileSerializer
    permission_classes = [permissions.IsAuthenticated, ]

    @action(detail=False, methods=['get', 'post'], permission_classes=[permissions.IsAuthenticated, ])
    def filetype(self, request:HttpRequest):
        args = self._get_arguments(request)
        if args[ArgMap.filetype] is None:
            raise ParseError("missing FileType argument")
        return File.objects.filter(FileType=args[ArgMap.filetype]).all()

    @action(detail=False, methods=['get', 'post'], permission_classes=[permissions.IsAuthenticated, ])
    def exists(self, request:HttpRequest):
        args = self._get_arguments(request)
        file_name = args[ArgMap.filename]
        archive = args[ArgMap.archive]
        if not file_name or not archive:
            raise ParseError("You have to supply a Path and Archive")
        search = File.objects.filter(Archive_id=archive).filter(FileName=file_name)
        file_exists = search.exists()
        if file_exists:
            first = search.first()
            file_id = first.id
            obj = FileSerializer(first).data
        else:
            file_id = None
            obj = {}
        return Response({"status": file_exists, "id": file_id, "obj": obj})


class VTResultViewSet(viewsets.ModelViewSet):
    queryset = VTResults.objects.all()
    serializer_class = VTResultSerializer
    permission_classes = [permissions.IsAuthenticated, ]


class MetadataViewSet(viewsets.ModelViewSet, MethodIndependentArgsMixin):
    queryset = Metadata.objects.all()
    serializer_class = MetadataSerializer
    permission_classes = [permissions.IsAuthenticated, ]

    @action(detail=False, methods=['get', 'post'], permission_classes=[permissions.IsAuthenticated, ])
    def search(self, request: HttpRequest):
        args = self._get_arguments(request)
        if args[ArgMap.md5] is None and args[ArgMap.ssdeep] is None and \
                args[ArgMap.sha1] is None and args[ArgMap.sha256] is None:
            raise ParseError("missing search argument. Need one of MD5, SHA1, SHA256, SSDeep")
        search = Metadata.objects
        if args[ArgMap.md5]:
            search = search.filter(MD5=args[ArgMap.md5])
        if args[ArgMap.sha1]:
            search = search.filter(SHA1=args[ArgMap.sha1])
        if args[ArgMap.sha256]:
            search = search.filter(SHA256=args[ArgMap.sha256])
        if args[ArgMap.ssdeep]:
            search = search.filter(SSDeep=args[ArgMap.ssdeep])
        return search.all()

    @action(detail=False, methods=['get', 'post'], permission_classes=[permissions.IsAuthenticated, ])
    def exists(self, request: HttpRequest):
        args = self._get_arguments(request)
        parent_file_id = args[ArgMap.file_id]
        if not parent_file_id:
            raise ParseError("You have to supply a file_id")
        search = Metadata.objects.filter(File__id=parent_file_id)
        file_exists = search.exists()
        if file_exists:
            first = search.first()
            file_id = first.id
            obj = FileSerializer(first).data
        else:
            file_id = None
            obj = {}
        return Response({"status": file_exists, "id": file_id, "obj": obj})


class PEHeaderInfoViewSet(viewsets.ModelViewSet, MethodIndependentArgsMixin):
    queryset = PEHeaderInfo.objects.all()
    serializer_class = PEHeaderInfoSerializer
    permission_classes = [permissions.IsAuthenticated, ]

    @action(detail=False, methods=['get', 'post'], permission_classes=[permissions.IsAuthenticated, ])
    def imphash(self, request: HttpRequest):
        args = self._get_arguments(request)
        if args[ArgMap.imphash] is None:
            raise ParseError("missing ImpHash argument.")
        return PEHeaderInfo.objects.filter(ImpHash=args[ArgMap.imphash]).all()

    @action(detail=False, methods=['get', 'post'], permission_classes=[permissions.IsAuthenticated, ])
    def compile_time_exact(self, request: HttpRequest):
        args = self._get_arguments(request)
        if args[ArgMap.compiletime] is None:
            raise ParseError("missing CompileTime argument.")
        return PEHeaderInfo.objects.filter(CompileTime=args[ArgMap.compiletime]).all()

    @action(detail=False, methods=['get', 'post'], permission_classes=[permissions.IsAuthenticated, ])
    def compile_time_near(self, request: HttpRequest):
        args = self._get_arguments(request)
        if args[ArgMap.compiletime] is None:
            raise ParseError("missing CompileTime argument.")
        start = args[ArgMap.compiletime] - timedelta(days=1)
        end = args[ArgMap.compiletime] - timedelta(days=1)
        return PEHeaderInfo.objects.filter(CompileTime__gt=start).filter(CompileTime__lt=end).all()

    @action(detail=False, methods=['get', 'post'], permission_classes=[permissions.IsAuthenticated, ])
    def exists(self, request: HttpRequest):
        args = self._get_arguments(request)
        parent_file_id = args[ArgMap.file_id]
        if not parent_file_id:
            raise ParseError("You have to supply a file_id")
        search = PEHeaderInfo.objects.filter(File__id=parent_file_id)
        file_exists = search.exists()
        if file_exists:
            first = search.first()
            file_id = first.id
            obj = FileSerializer(first).data
        else:
            file_id = None
            obj = {}
        return Response({"status": file_exists, "id": file_id, "obj": obj})


class ArchivedViewSet(viewsets.ModelViewSet, MethodIndependentArgsMixin):
    queryset = Archive.objects.all()
    serializer_class = ArchiveSerializer
    permission_classes = [permissions.IsAuthenticated, ]

    @action(detail=False, methods=['get', 'post'], permission_classes=[permissions.IsAuthenticated, ])
    def exists(self, request: HttpRequest):
        args = self._get_arguments(request)
        file_name = args[ArgMap.filename]
        path = args[ArgMap.path]
        if not file_name and not path:
            print(args)
            raise ParseError("You have to supply a Path or FileName")
        search = Archive.objects
        if file_name:
            search = search.filter(FileName=file_name)
        if path:
            search = search.filter(Path=path)
        file_exists = search.exists()
        if file_exists:
            first = search.first()
            file_id = first.id
            obj = ArchiveSerializer(first).data
        else:
            file_id = None
            obj = {}
        return Response({"status": file_exists, "id": file_id, "obj": obj})

    @action(detail=False, methods=['get', 'post'], permission_classes=[permissions.IsAuthenticated, ])
    def search(self, request:HttpRequest):
        args = self._get_arguments(request)
        search = Archive.objects
        if args['filename']:
            search = search.filter(FileName=args['filename'])
        if args['path']:
            search = search.filter(Path=args['path'])
        archive = search.first()
        return Response({"status": "found", "id": archive.id})


def index(_):
    return HttpResponse("hello")
